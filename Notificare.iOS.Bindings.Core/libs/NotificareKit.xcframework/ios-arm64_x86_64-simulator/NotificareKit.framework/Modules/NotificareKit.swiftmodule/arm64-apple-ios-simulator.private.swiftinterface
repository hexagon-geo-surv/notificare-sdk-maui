// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
// swift-module-flags: -target arm64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name NotificareKit
import CoreData
import DeveloperToolsSupport
import Foundation
@_exported import NotificareKit
import Swift
import SwiftUI
import SystemConfiguration
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os
public typealias NotificareCallback<T> = (Swift.Result<T, any Swift.Error>) -> Swift.Void
@_hasMissingDesignatedInitializers public class Notificare {
  public static let shared: NotificareKit.Notificare
  public static var SDK_VERSION: Swift.String {
    get
  }
  public var servicesInfo: NotificareKit.NotificareServicesInfo? {
    get
  }
  public var options: NotificareKit.NotificareOptions? {
    get
  }
  public var application: NotificareKit.NotificareApplication? {
    get
  }
  weak public var delegate: (any NotificareKit.NotificareDelegate)?
  public var isConfigured: Swift.Bool {
    get
  }
  public var isReady: Swift.Bool {
    get
  }
  public var canEvaluateDeferredLink: Swift.Bool {
    get
  }
  public func configure(servicesInfo: NotificareKit.NotificareServicesInfo? = nil, options: NotificareKit.NotificareOptions? = nil)
  public func configure(servicesInfo: NotificareKit.NotificareServicesInfo, options: NotificareKit.NotificareOptions)
  public func launch(_ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  public func launch() async throws
  #endif
  public func unlaunch(_ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  public func unlaunch() async throws
  #endif
  public func fetchApplication(_ completion: @escaping NotificareKit.NotificareCallback<NotificareKit.NotificareApplication>)
  #if compiler(>=5.3) && $AsyncAwait
  public func fetchApplication() async throws -> NotificareKit.NotificareApplication
  #endif
  public func fetchDynamicLink(_ link: Swift.String, _ completion: @escaping NotificareKit.NotificareCallback<NotificareKit.NotificareDynamicLink>)
  #if compiler(>=5.3) && $AsyncAwait
  public func fetchDynamicLink(_ link: Swift.String) async throws -> NotificareKit.NotificareDynamicLink
  #endif
  public func fetchNotification(_ id: Swift.String, _ completion: @escaping NotificareKit.NotificareCallback<NotificareKit.NotificareNotification>)
  #if compiler(>=5.3) && $AsyncAwait
  public func fetchNotification(_ id: Swift.String) async throws -> NotificareKit.NotificareNotification
  #endif
  public func createNotificationReply(notification: NotificareKit.NotificareNotification, action: NotificareKit.NotificareNotification.Action, message: Swift.String? = nil, media: Swift.String? = nil, mimeType: Swift.String? = nil, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  public func createNotificationReply(notification: NotificareKit.NotificareNotification, action: NotificareKit.NotificareNotification.Action, message: Swift.String? = nil, media: Swift.String? = nil, mimeType: Swift.String? = nil) async throws
  #endif
  public func callNotificationReplyWebhook(url: Foundation.URL, data: [Swift.String : Swift.String], _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  public func callNotificationReplyWebhook(url: Foundation.URL, data: [Swift.String : Swift.String]) async throws
  #endif
  public func uploadNotificationReplyAsset(_ data: Foundation.Data, contentType: Swift.String, _ completion: @escaping NotificareKit.NotificareCallback<Swift.String>)
  #if compiler(>=5.3) && $AsyncAwait
  public func uploadNotificationReplyAsset(_ data: Foundation.Data, contentType: Swift.String) async throws -> Swift.String
  #endif
  public func removeNotificationFromNotificationCenter(_ notification: NotificareKit.NotificareNotification)
  public func removeNotificationFromNotificationCenter(_ notificationId: Swift.String)
  public func handleTestDeviceUrl(_ url: Foundation.URL) -> Swift.Bool
  public func handleDynamicLinkUrl(_ url: Foundation.URL) -> Swift.Bool
  #if compiler(>=5.3) && $AsyncAwait
  @_Concurrency.MainActor public func evaluateDeferredLink() async throws -> Swift.Bool
  #endif
  public func evaluateDeferredLink(_ completion: @escaping NotificareKit.NotificareCallback<Swift.Bool>)
  @objc deinit
}
extension NotificareKit.NotificareInternals {
  public enum PushAPI {
    public enum Models {
    }
    public enum Payloads {
    }
    public enum Responses {
    }
  }
}
public enum NotificareIsoDateUtils {
  public static func parse(_ date: Swift.String) -> Foundation.Date?
  public static func format(_ date: Foundation.Date) -> Swift.String
}
public protocol NotificareEventsModule : AnyObject {
  func logNotificationOpen(_ id: Swift.String, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  func logNotificationOpen(_ id: Swift.String) async throws
  #endif
  func logCustom(_ event: Swift.String, data: NotificareKit.NotificareEventData?, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  func logCustom(_ event: Swift.String, data: NotificareKit.NotificareEventData?) async throws
  #endif
}
extension NotificareKit.NotificareEventsModule {
  public func logCustom(_ event: Swift.String, data: NotificareKit.NotificareEventData? = nil, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  public func logCustom(_ event: Swift.String, data: NotificareKit.NotificareEventData? = nil) async throws
  #endif
}
public protocol NotificareInternalEventsModule {
  #if compiler(>=5.3) && $AsyncAwait
  func log(_ event: Swift.String, data: NotificareKit.NotificareEventData?, sessionId: Swift.String?, notificationId: Swift.String?) async throws
  #endif
}
extension NotificareKit.NotificareInternalEventsModule {
  #if compiler(>=5.3) && $AsyncAwait
  public func log(_ event: Swift.String, data: NotificareKit.NotificareEventData? = nil, sessionId: Swift.String? = nil, notificationId: Swift.String? = nil) async throws
  #endif
}
open class NotificareAbstractDatabase {
  public var persistentContainer: CoreData.NSPersistentContainer {
    get
    set
  }
  public var context: CoreData.NSManagedObjectContext {
    get
  }
  public init(name: Swift.String, rebuildOnVersionChange: Swift.Bool = true, mergePolicy: CoreData.NSMergePolicy? = nil)
  public func configure()
  public func ensureLoadedStores()
  public func saveChanges()
  @objc deinit
}
public enum NotificareInternals {
  public enum Module : Swift.String, Swift.CaseIterable {
    case events
    case session
    case device
    case crashReporter
    case push
    case pushUI
    case inbox
    case loyalty
    case assets
    case scannables
    case geo
    case inAppMessaging
    case userInbox
    public var isAvailable: Swift.Bool {
      get
    }
    public var klass: (any NotificareKit.NotificareModule.Type)? {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias AllCases = [NotificareKit.NotificareInternals.Module]
    public typealias RawValue = Swift.String
    public static var allCases: [NotificareKit.NotificareInternals.Module] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
extension NotificareKit.NotificareInternals.PushAPI.Models {
  public struct Application : Swift.Decodable {
    public let _id: Swift.String
    public let name: Swift.String
    public let category: Swift.String
    public let appStoreId: Swift.String?
    public let services: [Swift.String : Swift.Bool]
    public let inboxConfig: NotificareKit.NotificareApplication.InboxConfig?
    public let regionConfig: NotificareKit.NotificareApplication.RegionConfig?
    public let userDataFields: [NotificareKit.NotificareApplication.UserDataField]
    public let actionCategories: [NotificareKit.NotificareInternals.PushAPI.Models.Application.ActionCategory]
    public struct ActionCategory : Swift.Decodable {
      public let name: Swift.String
      public let description: Swift.String?
      public let type: Swift.String
      public let actions: [NotificareKit.NotificareInternals.PushAPI.Models.Notification.Action]
      public init(from decoder: any Swift.Decoder) throws
    }
    public func toModel() -> NotificareKit.NotificareApplication
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Notification : Swift.Decodable {
    public let _id: Swift.String
    public let type: Swift.String
    public let time: Foundation.Date
    public let title: Swift.String?
    public let subtitle: Swift.String?
    public let message: Swift.String
    public let content: [NotificareKit.NotificareNotification.Content]
    public let actions: [NotificareKit.NotificareInternals.PushAPI.Models.Notification.Action]
    public let attachments: [NotificareKit.NotificareNotification.Attachment]
    public let extra: [Swift.String : Any]
    public let targetContentIdentifier: Swift.String?
    public init(from decoder: any Swift.Decoder) throws
    public struct Action : Swift.Decodable {
      public let type: Swift.String
      public let label: Swift.String?
      public let target: Swift.String?
      public let keyboard: Swift.Bool?
      public let camera: Swift.Bool?
      public let destructive: Swift.Bool?
      public let icon: NotificareKit.NotificareNotification.Action.Icon?
      public func toModel() -> NotificareKit.NotificareNotification.Action?
      public init(from decoder: any Swift.Decoder) throws
    }
    public func toModel() -> NotificareKit.NotificareNotification
  }
}
public struct NotificareDynamicLink : Swift.Codable {
  public let target: Swift.String
  public init(target: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension NotificareKit.NotificareDynamicLink {
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareDynamicLink
}
@propertyWrapper public struct EncodeNull<T> : Swift.Encodable where T : Swift.Encodable {
  public let wrappedValue: T?
  public init(wrappedValue: T?)
  public func encode(to encoder: any Swift.Encoder) throws
}
public protocol NotificareDelegate : AnyObject {
  func notificare(_ notificare: NotificareKit.Notificare, onReady application: NotificareKit.NotificareApplication)
  func notificareDidUnlaunch(_ notificare: NotificareKit.Notificare)
  func notificare(_ notificare: NotificareKit.Notificare, didRegisterDevice device: NotificareKit.NotificareDevice)
}
extension NotificareKit.NotificareDelegate {
  public func notificare(_: NotificareKit.Notificare, didRegisterDevice _: NotificareKit.NotificareDevice)
  public func notificareDidUnlaunch(_: NotificareKit.Notificare)
}
public protocol NotificareModule {
  associatedtype Instance : NotificareKit.NotificareModule
  static var instance: Self.Instance { get }
  func migrate()
  func configure()
  #if compiler(>=5.3) && $AsyncAwait
  func launch() async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func postLaunch() async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  func unlaunch() async throws
  #endif
}
extension NotificareKit.NotificareModule {
  public func migrate()
  public func configure()
  #if compiler(>=5.3) && $AsyncAwait
  public func launch() async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func postLaunch() async throws
  #endif
  #if compiler(>=5.3) && $AsyncAwait
  public func unlaunch() async throws
  #endif
}
extension Foundation.URL {
  public func appendingQueryComponent(name: Swift.String, value: Swift.String) -> Foundation.URL
  public mutating func appendQueryComponent(name: Swift.String, value: Swift.String)
  public func removingQueryComponent(name: Swift.String) -> Foundation.URL
  public mutating func removeQueryComponent(name: Swift.String)
}
public enum NotificareError : Swift.Error {
  case notConfigured
  case notReady
  case deviceUnavailable
  case applicationUnavailable
  case serviceUnavailable(service: Swift.String)
  case invalidArgument(message: Swift.String)
}
public struct NotificareApplication : Swift.Codable {
  public let id: Swift.String
  public let name: Swift.String
  public let category: Swift.String
  public let appStoreId: Swift.String?
  public let services: [Swift.String : Swift.Bool]
  public let inboxConfig: NotificareKit.NotificareApplication.InboxConfig?
  public let regionConfig: NotificareKit.NotificareApplication.RegionConfig?
  public let userDataFields: [NotificareKit.NotificareApplication.UserDataField]
  public let actionCategories: [NotificareKit.NotificareApplication.ActionCategory]
  public init(id: Swift.String, name: Swift.String, category: Swift.String, appStoreId: Swift.String?, services: [Swift.String : Swift.Bool], inboxConfig: NotificareKit.NotificareApplication.InboxConfig?, regionConfig: NotificareKit.NotificareApplication.RegionConfig?, userDataFields: [NotificareKit.NotificareApplication.UserDataField], actionCategories: [NotificareKit.NotificareApplication.ActionCategory])
  public enum ServiceKey : Swift.String {
    case oauth2
    case richPush
    case locationServices
    case apns
    case gcm
    case websockets
    case passbook
    case inAppPurchase
    case inbox
    case storage
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct InboxConfig : Swift.Codable {
    public let useInbox: Swift.Bool
    public let useUserInbox: Swift.Bool
    public let autoBadge: Swift.Bool
    public init(useInbox: Swift.Bool, useUserInbox: Swift.Bool, autoBadge: Swift.Bool)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct RegionConfig : Swift.Codable {
    public let proximityUUID: Swift.String?
    public init(proximityUUID: Swift.String?)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct UserDataField : Swift.Codable {
    public let type: Swift.String
    public let key: Swift.String
    public let label: Swift.String
    public init(type: Swift.String, key: Swift.String, label: Swift.String)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct ActionCategory : Swift.Codable {
    public let name: Swift.String
    public let description: Swift.String?
    public let type: Swift.String
    public let actions: [NotificareKit.NotificareNotification.Action]
    public init(name: Swift.String, description: Swift.String?, type: Swift.String, actions: [NotificareKit.NotificareNotification.Action])
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension NotificareKit.NotificareApplication : Swift.Identifiable {
  public typealias ID = Swift.String
}
extension NotificareKit.NotificareApplication {
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareApplication
}
extension NotificareKit.NotificareApplication.InboxConfig {
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareApplication.InboxConfig
}
extension NotificareKit.NotificareApplication.RegionConfig {
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareApplication.RegionConfig
}
extension NotificareKit.NotificareApplication.UserDataField {
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareApplication.UserDataField
}
extension NotificareKit.NotificareApplication.ActionCategory {
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareApplication.ActionCategory
}
public enum NotificareLogger {
  public static func debug(_ message: Swift.String, error: (any Swift.Error)? = nil, file: Swift.String = #file)
  public static func info(_ message: Swift.String, error: (any Swift.Error)? = nil, file: Swift.String = #file)
  public static func warning(_ message: Swift.String, error: (any Swift.Error)? = nil, file: Swift.String = #file)
  public static func error(_ message: Swift.String, error: (any Swift.Error)? = nil, file: Swift.String = #file)
}
extension NotificareKit.Notificare {
  public func device() -> any NotificareKit.NotificareDeviceModule
  public func events() -> any NotificareKit.NotificareEventsModule
}
@objc public protocol NotificareAppDelegateInterceptor {
  @objc optional func application(_ application: UIKit.UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Foundation.Data)
  @objc optional func application(_ application: UIKit.UIApplication, didFailToRegisterForRemoteNotificationsWithError error: any Swift.Error)
  @objc optional func application(_ application: UIKit.UIApplication, didReceiveRemoteNotification userInfo: [Swift.AnyHashable : Any], fetchCompletionHandler completionHandler: @escaping (UIKit.UIBackgroundFetchResult) -> Swift.Void)
  @objc optional func application(_ app: UIKit.UIApplication, open url: Foundation.URL, options: [UIKit.UIApplication.OpenURLOptionsKey : Any]) -> Swift.Bool
  @objc optional func application(_ application: UIKit.UIApplication, continue userActivity: Foundation.NSUserActivity, restorationHandler: @escaping ([any UIKit.UIUserActivityRestoring]?) -> Swift.Void) -> Swift.Bool
}
public enum NotificareNetworkError : Swift.Error {
  case inaccessible
  case urlError(Foundation.URLError)
  case genericError(any Swift.Error)
  case noResponse
  case invalidResponseType(Foundation.URLResponse)
  case noResponseData(Foundation.HTTPURLResponse)
  case endpointError(Foundation.HTTPURLResponse, Foundation.Data?)
  case validationError(response: Foundation.HTTPURLResponse, data: Foundation.Data?, validStatusCodes: Swift.ClosedRange<Swift.Int>)
}
extension NotificareKit.NotificareNetworkError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
  public var failureReason: Swift.String? {
    get
  }
}
@objc @_inheritsConvenienceInitializers public class NotificareAutoConfig : ObjectiveC.NSObject {
  @objc public static func setup()
  @objc override dynamic public init()
  @objc deinit
}
public struct NotificareNotification : Swift.Codable {
  public let partial: Swift.Bool
  public let id: Swift.String
  public let type: Swift.String
  public let time: Foundation.Date
  public let title: Swift.String?
  public let subtitle: Swift.String?
  public let message: Swift.String
  public let content: [NotificareKit.NotificareNotification.Content]
  public let actions: [NotificareKit.NotificareNotification.Action]
  public let attachments: [NotificareKit.NotificareNotification.Attachment]
  public let extra: [Swift.String : Any]
  public let targetContentIdentifier: Swift.String?
  public init(partial: Swift.Bool, id: Swift.String, type: Swift.String, time: Foundation.Date, title: Swift.String?, subtitle: Swift.String?, message: Swift.String, content: [NotificareKit.NotificareNotification.Content], actions: [NotificareKit.NotificareNotification.Action], attachments: [NotificareKit.NotificareNotification.Attachment], extra: [Swift.String : Any], targetContentIdentifier: Swift.String?)
  public enum NotificationType : Swift.String {
    case none
    case alert
    case inAppBrowser
    case webView
    case url
    case urlResolver
    case urlScheme
    case image
    case video
    case map
    case rate
    case passbook
    case store
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct Content : Swift.Codable {
    public let type: Swift.String
    public let data: Any
    public init(type: Swift.String, data: Any)
  }
  public struct Action : Swift.Codable {
    public let type: Swift.String
    public let label: Swift.String
    public let target: Swift.String?
    public let keyboard: Swift.Bool
    public let camera: Swift.Bool
    public let destructive: Swift.Bool?
    public let icon: NotificareKit.NotificareNotification.Action.Icon?
    public init(type: Swift.String, label: Swift.String, target: Swift.String?, keyboard: Swift.Bool, camera: Swift.Bool, destructive: Swift.Bool?, icon: NotificareKit.NotificareNotification.Action.Icon?)
    public enum ActionType : Swift.String {
      case app
      case browser
      case callback
      case custom
      case mail
      case sms
      case telephone
      case inAppBrowser
      @available(*, deprecated, renamed: "inAppBrowser", message: "The WebView action type becomes a backwards compatible alias. Use the InAppBrowser action type instead.")
      case webView
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public struct Icon : Swift.Codable {
      public let android: Swift.String?
      public let ios: Swift.String?
      public let web: Swift.String?
      public init(android: Swift.String?, ios: Swift.String?, web: Swift.String?)
      public func encode(to encoder: any Swift.Encoder) throws
      public init(from decoder: any Swift.Decoder) throws
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  public struct Attachment : Swift.Codable {
    public let mimeType: Swift.String
    public let uri: Swift.String
    public init(mimeType: Swift.String, uri: Swift.String)
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension NotificareKit.NotificareNotification : Swift.Identifiable {
  public typealias ID = Swift.String
}
extension NotificareKit.NotificareNotification {
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareNotification
}
extension NotificareKit.NotificareNotification {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension NotificareKit.NotificareNotification.Content {
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareNotification.Content
}
extension NotificareKit.NotificareNotification.Content {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension NotificareKit.NotificareNotification.Action {
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareNotification.Action
}
extension NotificareKit.NotificareNotification.Action.Icon {
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareNotification.Action.Icon
}
extension NotificareKit.NotificareNotification.Attachment {
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareNotification.Attachment
}
@frozen public struct NotificareAnyEncodable : Swift.Encodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _NotificareAnyEncodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension NotificareKit.NotificareAnyEncodable : NotificareKit._NotificareAnyEncodable {
}
extension NotificareKit._NotificareAnyEncodable {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension NotificareKit.NotificareAnyEncodable : Swift.Equatable {
  public static func == (lhs: NotificareKit.NotificareAnyEncodable, rhs: NotificareKit.NotificareAnyEncodable) -> Swift.Bool
}
extension NotificareKit.NotificareAnyEncodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension NotificareKit.NotificareAnyEncodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension NotificareKit.NotificareAnyEncodable : Swift.ExpressibleByNilLiteral {
}
extension NotificareKit.NotificareAnyEncodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension NotificareKit.NotificareAnyEncodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension NotificareKit.NotificareAnyEncodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension NotificareKit.NotificareAnyEncodable : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension NotificareKit.NotificareAnyEncodable : Swift.ExpressibleByStringInterpolation {
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
}
extension NotificareKit.NotificareAnyEncodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension NotificareKit.NotificareAnyEncodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
extension NotificareKit._NotificareAnyEncodable {
  public init(nilLiteral _: ())
  public init(booleanLiteral value: Swift.Bool)
  public init(integerLiteral value: Swift.Int)
  public init(floatLiteral value: Swift.Double)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(arrayLiteral elements: Any...)
  public init(dictionaryLiteral elements: (Swift.AnyHashable, Any)...)
}
public struct NotificareTime {
  public let hours: Swift.Int
  public let minutes: Swift.Int
  public init(hours: Swift.Int, minutes: Swift.Int) throws
  public init(string: Swift.String) throws
  public func format() -> Swift.String
}
extension NotificareKit.NotificareTime : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public typealias NotificareUserData = [Swift.String : Swift.String]
public struct NotificareDevice : Swift.Codable {
  public let id: Swift.String
  public let userId: Swift.String?
  public let userName: Swift.String?
  public let timeZoneOffset: Swift.Float
  public let dnd: NotificareKit.NotificareDoNotDisturb?
  public let userData: NotificareKit.NotificareUserData
  public let backgroundAppRefresh: Swift.Bool
  public init(id: Swift.String, userId: Swift.String? = nil, userName: Swift.String? = nil, timeZoneOffset: Swift.Float, dnd: NotificareKit.NotificareDoNotDisturb? = nil, userData: NotificareKit.NotificareUserData, backgroundAppRefresh: Swift.Bool)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension NotificareKit.NotificareDevice : Swift.Identifiable {
  public typealias ID = Swift.String
}
extension NotificareKit.NotificareDevice {
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareDevice
}
public enum NotificareUtils {
  public static var applicationName: Swift.String {
    get
  }
  public static var applicationVersion: Swift.String {
    get
  }
  public static var deviceString: Swift.String {
    get
  }
  public static var deviceLanguage: Swift.String {
    get
  }
  public static var deviceRegion: Swift.String {
    get
  }
  public static var osVersion: Swift.String {
    get
  }
  public static var timeZoneOffset: Swift.Float {
    get
  }
  public static var userAgent: Swift.String {
    get
  }
  public static func getEnabledPeerModules() -> [Swift.String]
  public static let jsonDecoder: Foundation.JSONDecoder
  public static let jsonEncoder: Foundation.JSONEncoder
  public static func getSupportedUrlSchemes() -> [Swift.String]
  public static var rootViewController: UIKit.UIViewController? {
    get
  }
}
public struct NotificareServicesInfo : Swift.Decodable {
  public let applicationKey: Swift.String
  public let applicationSecret: Swift.String
  public let hosts: NotificareKit.NotificareServicesInfo.Hosts
  public init(applicationKey: Swift.String, applicationSecret: Swift.String, hosts: NotificareKit.NotificareServicesInfo.Hosts = Hosts())
  public init?(contentsOfFile plistPath: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
  public struct Hosts : Swift.Decodable {
    public let restApi: Swift.String
    public let appLinks: Swift.String
    public let shortLinks: Swift.String
    public init()
    public init(restApi: Swift.String, appLinks: Swift.String, shortLinks: Swift.String)
    public init(from decoder: any Swift.Decoder) throws
  }
}
@objc @_inheritsConvenienceInitializers public class NotificareSwizzler : Foundation.NSProxy {
  public static func setup(withRemoteNotifications: Swift.Bool = false)
  public static func addInterceptor(_ interceptor: any NotificareKit.NotificareAppDelegateInterceptor) -> Swift.String?
  public static func removeInterceptor(_ interceptor: any NotificareKit.NotificareAppDelegateInterceptor)
  @objc deinit
}
extension Swift.KeyedDecodingContainer {
  public func decode(_ type: [Swift.String : Any].Type, forKey key: K) throws -> [Swift.String : Any]
  public func decodeIfPresent(_ type: [Swift.String : Any].Type, forKey key: K) throws -> [Swift.String : Any]?
  public func decode(_ type: [Any].Type, forKey key: K) throws -> [Any]
  public func decodeIfPresent(_ type: [Any].Type, forKey key: K) throws -> [Any]?
  public func decode(_: [Swift.String : Any].Type) throws -> [Swift.String : Any]
}
extension Swift.UnkeyedDecodingContainer {
  public mutating func decode(_: [Any].Type) throws -> [Any]
  public mutating func decode(_ type: [Swift.String : Any].Type) throws -> [Swift.String : Any]
}
public typealias NotificareEventData = [Swift.String : Any]
public struct NotificareEvent {
  public let type: Swift.String
  public let timestamp: Swift.Int64
  public let deviceId: Swift.String
  public let sessionId: Swift.String?
  public let notificationId: Swift.String?
  public let userId: Swift.String?
  public let data: NotificareKit.NotificareEventData?
}
extension NotificareKit.NotificareEvent : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public protocol NotificareDeviceModule : AnyObject {
  var currentDevice: NotificareKit.NotificareDevice? { get }
  var preferredLanguage: Swift.String? { get }
  @available(*, deprecated, renamed: "updateUser")
  func register(userId: Swift.String?, userName: Swift.String?, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  @available(*, deprecated, renamed: "updateUser")
  func register(userId: Swift.String?, userName: Swift.String?) async throws
  #endif
  func updateUser(userId: Swift.String?, userName: Swift.String?, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  func updateUser(userId: Swift.String?, userName: Swift.String?) async throws
  #endif
  func updatePreferredLanguage(_ preferredLanguage: Swift.String?, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  func updatePreferredLanguage(_ preferredLanguage: Swift.String?) async throws
  #endif
  func fetchTags(_ completion: @escaping NotificareKit.NotificareCallback<[Swift.String]>)
  #if compiler(>=5.3) && $AsyncAwait
  func fetchTags() async throws -> [Swift.String]
  #endif
  func addTag(_ tag: Swift.String, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  func addTag(_ tag: Swift.String) async throws
  #endif
  func addTags(_ tags: [Swift.String], _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  func addTags(_ tags: [Swift.String]) async throws
  #endif
  func removeTag(_ tag: Swift.String, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  func removeTag(_ tag: Swift.String) async throws
  #endif
  func removeTags(_ tags: [Swift.String], _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  func removeTags(_ tags: [Swift.String]) async throws
  #endif
  func clearTags(_ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  func clearTags() async throws
  #endif
  func fetchDoNotDisturb(_ completion: @escaping NotificareKit.NotificareCallback<NotificareKit.NotificareDoNotDisturb?>)
  #if compiler(>=5.3) && $AsyncAwait
  func fetchDoNotDisturb() async throws -> NotificareKit.NotificareDoNotDisturb?
  #endif
  func updateDoNotDisturb(_ dnd: NotificareKit.NotificareDoNotDisturb, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  func updateDoNotDisturb(_ dnd: NotificareKit.NotificareDoNotDisturb) async throws
  #endif
  func clearDoNotDisturb(_ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  func clearDoNotDisturb() async throws
  #endif
  func fetchUserData(_ completion: @escaping NotificareKit.NotificareCallback<NotificareKit.NotificareUserData>)
  #if compiler(>=5.3) && $AsyncAwait
  func fetchUserData() async throws -> NotificareKit.NotificareUserData
  #endif
  func updateUserData(_ userData: NotificareKit.NotificareUserData, _ completion: @escaping NotificareKit.NotificareCallback<Swift.Void>)
  #if compiler(>=5.3) && $AsyncAwait
  func updateUserData(_ userData: NotificareKit.NotificareUserData) async throws
  #endif
}
public enum ReachabilityError : Swift.Error {
  case failedToCreateWithAddress(Darwin.sockaddr, Swift.Int32)
  case failedToCreateWithHostname(Swift.String, Swift.Int32)
  case unableToSetCallback(Swift.Int32)
  case unableToSetDispatchQueue(Swift.Int32)
  case unableToGetFlags(Swift.Int32)
}
extension Foundation.NSNotification.Name {
  public static let reachabilityChanged: Foundation.Notification.Name
}
public class NotificareReachability {
  public typealias NetworkReachable = (NotificareKit.NotificareReachability) -> Swift.Void
  public typealias NetworkUnreachable = (NotificareKit.NotificareReachability) -> Swift.Void
  public enum Connection : Swift.CustomStringConvertible {
    case unavailable, wifi, cellular
    public var description: Swift.String {
      get
    }
    public static func == (a: NotificareKit.NotificareReachability.Connection, b: NotificareKit.NotificareReachability.Connection) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var whenReachable: NotificareKit.NotificareReachability.NetworkReachable?
  public var whenUnreachable: NotificareKit.NotificareReachability.NetworkUnreachable?
  public var allowsCellularConnection: Swift.Bool
  public var notificationCenter: Foundation.NotificationCenter
  public var connection: NotificareKit.NotificareReachability.Connection {
    get
  }
  required public init(reachabilityRef: SystemConfiguration.SCNetworkReachability, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main)
  convenience public init(hostname: Swift.String, queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  convenience public init(queueQoS: Dispatch.DispatchQoS = .default, targetQueue: Dispatch.DispatchQueue? = nil, notificationQueue: Dispatch.DispatchQueue? = .main) throws
  @objc deinit
}
extension NotificareKit.NotificareReachability {
  public func startNotifier() throws
  public func stopNotifier()
  public var description: Swift.String {
    get
  }
}
@frozen public struct NotificareAnyCodable : Swift.Codable {
  public let value: Any
  public init<T>(_ value: T?)
}
extension NotificareKit.NotificareAnyCodable : NotificareKit._NotificareAnyEncodable, NotificareKit._NotificareAnyDecodable {
}
extension NotificareKit.NotificareAnyCodable : Swift.Equatable {
  public static func == (lhs: NotificareKit.NotificareAnyCodable, rhs: NotificareKit.NotificareAnyCodable) -> Swift.Bool
}
extension NotificareKit.NotificareAnyCodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension NotificareKit.NotificareAnyCodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension NotificareKit.NotificareAnyCodable : Swift.ExpressibleByNilLiteral {
}
extension NotificareKit.NotificareAnyCodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension NotificareKit.NotificareAnyCodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension NotificareKit.NotificareAnyCodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension NotificareKit.NotificareAnyCodable : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension NotificareKit.NotificareAnyCodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension NotificareKit.NotificareAnyCodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
public struct NotificareDoNotDisturb : Swift.Codable {
  public let start: NotificareKit.NotificareTime
  public let end: NotificareKit.NotificareTime
  public init(start: NotificareKit.NotificareTime, end: NotificareKit.NotificareTime)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension NotificareKit.NotificareDoNotDisturb {
  public func toJson() throws -> [Swift.String : Any]
  public static func fromJson(json: [Swift.String : Any]) throws -> NotificareKit.NotificareDoNotDisturb
}
@frozen public struct NotificareAnyDecodable : Swift.Decodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _NotificareAnyDecodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension NotificareKit.NotificareAnyDecodable : NotificareKit._NotificareAnyDecodable {
}
extension NotificareKit._NotificareAnyDecodable {
  public init(from decoder: any Swift.Decoder) throws
}
extension NotificareKit.NotificareAnyDecodable : Swift.Equatable {
  public static func == (lhs: NotificareKit.NotificareAnyDecodable, rhs: NotificareKit.NotificareAnyDecodable) -> Swift.Bool
}
extension NotificareKit.NotificareAnyDecodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension NotificareKit.NotificareAnyDecodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Foundation.URLRequest {
  public mutating func setNotificareHeaders()
  public mutating func setMethod(_ method: Swift.String, payload: Foundation.Data? = nil)
}
extension Foundation.URLSession {
  public static var maximumNumberOfRetries: Swift.Int
  public typealias DataResult = Swift.Result<(response: Foundation.HTTPURLResponse, data: Foundation.Data?), NotificareKit.NotificareNetworkError>
  public typealias Callback = (Foundation.URLSession.DataResult) -> Swift.Void
  public func perform(_ urlRequest: Foundation.URLRequest, maxRetries: Swift.Int = URLSession.maximumNumberOfRetries, allowEmptyData: Swift.Bool = false, callback: @escaping Foundation.URLSession.Callback)
}
public struct NotificareRequest {
  public func response(_ completion: @escaping NotificareKit.NotificareCallback<(response: Foundation.HTTPURLResponse, data: Foundation.Data?)>)
  public func responseDecodable<T>(_ type: T.Type, _ completion: @escaping (Swift.Result<T, any Swift.Error>) -> Swift.Void) where T : Swift.Decodable
  public class Builder {
    public init()
    public func baseUrl(url: Swift.String) -> Self
    public func get(_ url: Swift.String) -> Self
    public func patch(_ url: Swift.String) -> Self
    public func patch<T>(_ url: Swift.String, body: T?) -> Self where T : Swift.Encodable
    public func post(_ url: Swift.String) -> Self
    public func post<T>(_ url: Swift.String, body: T?) -> Self where T : Swift.Encodable
    public func post(_ url: Swift.String, body: [Foundation.URLQueryItem]) -> Self
    public func post(_ url: Swift.String, body: Foundation.Data, contentType: Swift.String) -> Self
    public func put(_ url: Swift.String) -> Self
    public func put<T>(_ url: Swift.String, body: T?) -> Self where T : Swift.Encodable
    public func delete(_ url: Swift.String) -> Self
    public func delete<T>(_ url: Swift.String, body: T?) -> Self where T : Swift.Encodable
    public func query(items: [Swift.String : Swift.String?]) -> Self
    public func query(name: Swift.String, value: Swift.String?) -> Self
    public func header(name: Swift.String, value: Swift.String?) -> Self
    public func authentication(_ authentication: NotificareKit.NotificareRequest.Authentication?) -> Self
    public func validate(range: Swift.ClosedRange<Swift.Int>) -> Self
    public func build() throws -> NotificareKit.NotificareRequest
    public func response(_ completion: @escaping (Swift.Result<(response: Foundation.HTTPURLResponse, data: Foundation.Data?), any Swift.Error>) -> Swift.Void)
    #if compiler(>=5.3) && $AsyncAwait
    @discardableResult
    public func response() async throws -> (response: Foundation.HTTPURLResponse, data: Foundation.Data?)
    #endif
    public func responseDecodable<T>(_ type: T.Type, _ completion: @escaping (Swift.Result<T, any Swift.Error>) -> Swift.Void) where T : Swift.Decodable
    #if compiler(>=5.3) && $AsyncAwait
    public func responseDecodable<T>(_ type: T.Type) async throws -> T where T : Swift.Decodable
    #endif
    @objc deinit
  }
  public enum Authentication {
    case basic(username: Swift.String, password: Swift.String)
    public func encode() -> Swift.String
  }
}
@_hasMissingDesignatedInitializers public class NotificareLocalizable {
  public static func string(resource: NotificareKit.NotificareLocalizable.StringResource) -> Swift.String
  public static func string(resource: Swift.String, fallback: Swift.String) -> Swift.String
  public static func image(resource: NotificareKit.NotificareLocalizable.ImageResource) -> UIKit.UIImage?
  public enum StringResource : Swift.String {
    case okButton
    case cancelButton
    case closeButton
    case sendButton
    case actionsButton
    case pushDefaultCategory
    case actionsInputPlaceholder
    case actionsShareImageTextPlaceholder
    case rateAlertYesButton
    case rateAlertNoButton
    case mapUnknownTitleMarker
    case actionMailSubject
    case actionMailBody
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ImageResource : Swift.String {
    case actions
    case mapMarker
    case mapMarkerUserLocation
    case close
    case closeCircle
    case send
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  @objc deinit
}
public protocol NotificareLoyaltyIntegration {
  var canPresentPasses: Swift.Bool { get }
  func present(notification: NotificareKit.NotificareNotification, in viewController: UIKit.UIViewController)
}
extension Swift.Dictionary {
  public func mapKeys<Transformed>(_ transform: (Key) throws -> Transformed) rethrows -> [Transformed : Value] where Transformed : Swift.Hashable
}
extension Foundation.Data {
  public func toHexString() -> Swift.String
}
extension UIKit.UIColor {
  convenience public init(hexString: Swift.String, alpha: CoreFoundation.CGFloat = 1.0)
  public func toHexString() -> Swift.String
}
public struct NotificareOptions : Swift.Decodable {
  public static let DEFAULT_DEBUG_LOGGING_ENABLED: Swift.Bool
  public static let DEFAULT_AUTO_CONFIG: Swift.Bool
  public static let DEFAULT_SWIZZLING_ENABLED: Swift.Bool
  public static let DEFAULT_USER_NOTIFICATION_CENTER_DELEGATE_ENABLED: Swift.Bool
  public static let DEFAULT_PRESERVE_EXISTING_NOTIFICATION_CATEGORIES: Swift.Bool
  public static let DEFAULT_CRASH_REPORTS_ENABLED: Swift.Bool
  public static let DEFAULT_HEADING_API_ENABLED: Swift.Bool
  public static let DEFAULT_VISITS_API_ENABLED: Swift.Bool
  public static let DEFAULT_IMAGE_SHARING_ENABLED: Swift.Bool
  public static let DEFAULT_IAM_BACKGROUND_GRACE_PERIOD_MILLIS: Swift.Int
  public static let DEFAULT_OVERRIDE_DATABASE_FILE_PROTECTION: Swift.Bool
  public static let DEFAULT_LEGACY_NOTIFICATIONS_USER_INTERFACE_ENABLED: Swift.Bool
  public let debugLoggingEnabled: Swift.Bool
  public let autoConfig: Swift.Bool
  public let swizzlingEnabled: Swift.Bool
  public let userNotificationCenterDelegateEnabled: Swift.Bool
  public let preserveExistingNotificationCategories: Swift.Bool
  public let crashReportsEnabled: Swift.Bool
  public let headingApiEnabled: Swift.Bool
  public let visitsApiEnabled: Swift.Bool
  public let urlSchemes: [Swift.String]
  public let closeWindowQueryParameter: Swift.String?
  public let imageSharingEnabled: Swift.Bool
  public let safariDismissButtonStyle: Swift.Int?
  public let themes: NotificareKit.NotificareOptions.Themes?
  public let backgroundGracePeriodMillis: Swift.Int
  public let overrideDatabaseFileProtection: Swift.Bool
  public let monitoredRegionsLimit: Swift.Int?
  public let legacyNotificationsUserInterfaceEnabled: Swift.Bool
  public init(debugLoggingEnabled: Swift.Bool = DEFAULT_DEBUG_LOGGING_ENABLED, autoConfig: Swift.Bool = DEFAULT_AUTO_CONFIG, swizzlingEnabled: Swift.Bool = DEFAULT_SWIZZLING_ENABLED, userNotificationCenterDelegateEnabled: Swift.Bool = DEFAULT_USER_NOTIFICATION_CENTER_DELEGATE_ENABLED, preserveExistingNotificationCategories: Swift.Bool = DEFAULT_PRESERVE_EXISTING_NOTIFICATION_CATEGORIES, crashReportsEnabled: Swift.Bool = DEFAULT_CRASH_REPORTS_ENABLED, headingApiEnabled: Swift.Bool = DEFAULT_HEADING_API_ENABLED, visitsApiEnabled: Swift.Bool = DEFAULT_VISITS_API_ENABLED, urlSchemes: [Swift.String] = [], closeWindowQueryParameter: Swift.String? = nil, imageSharingEnabled: Swift.Bool = DEFAULT_IMAGE_SHARING_ENABLED, safariDismissButtonStyle: Swift.Int? = nil, themes: NotificareKit.NotificareOptions.Themes? = nil, backgroundGracePeriodMillis: Swift.Int = DEFAULT_IAM_BACKGROUND_GRACE_PERIOD_MILLIS, overrideDatabaseFileProtection: Swift.Bool = DEFAULT_OVERRIDE_DATABASE_FILE_PROTECTION, monitoredRegionsLimit: Swift.Int? = nil, legacyNotificationsUserInterfaceEnabled: Swift.Bool = DEFAULT_LEGACY_NOTIFICATIONS_USER_INTERFACE_ENABLED)
  public struct Themes : Swift.Decodable {
    public let light: NotificareKit.NotificareOptions.Theme?
    public let dark: NotificareKit.NotificareOptions.Theme?
    public init(light: NotificareKit.NotificareOptions.Theme?, dark: NotificareKit.NotificareOptions.Theme?)
  }
  public struct Theme : Swift.Decodable {
    public let backgroundColor: Swift.String?
    public let actionButtonTextColor: Swift.String?
    public let toolbarBackgroundColor: Swift.String?
    public let activityIndicatorColor: Swift.String?
    public let buttonTextColor: Swift.String?
    public let textFieldTextColor: Swift.String?
    public let textFieldBackgroundColor: Swift.String?
    public let safariBarTintColor: Swift.String?
    public let safariControlsTintColor: Swift.String?
    public init(backgroundColor: Swift.String?, actionButtonTextColor: Swift.String?, toolbarBackgroundColor: Swift.String?, activityIndicatorColor: Swift.String?, buttonTextColor: Swift.String?, textFieldTextColor: Swift.String?, textFieldBackgroundColor: Swift.String?, safariBarTintColor: Swift.String?, safariControlsTintColor: Swift.String?)
  }
}
extension NotificareKit.NotificareOptions {
  public init?(contentsOfFile plistPath: Swift.String)
}
extension NotificareKit.NotificareOptions {
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case debugLoggingEnabled
    case autoConfig
    case swizzlingEnabled
    case userNotificationCenterDelegateEnabled
    case preserveExistingNotificationCategories
    case crashReportsEnabled
    case headingApiEnabled
    case visitsApiEnabled
    case urlSchemes
    case closeWindowQueryParameter
    case imageSharingEnabled
    case safariDismissButtonStyle
    case themes
    case backgroundGracePeriodMillis
    case overrideDatabaseFileProtection
    case monitoredRegionsLimit
    case legacyNotificationsUserInterfaceEnabled
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension NotificareKit.NotificareOptions.Themes {
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case light
    case dark
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension NotificareKit.NotificareOptions.Theme {
  public enum CodingKeys : Swift.String, Swift.CodingKey {
    case backgroundColor
    case actionButtonTextColor
    case toolbarBackgroundColor
    case activityIndicatorColor
    case buttonTextColor
    case textFieldTextColor
    case textFieldBackgroundColor
    case safariBarTintColor
    case safariControlsTintColor
    public init?(rawValue: Swift.String)
    public init?(stringValue: Swift.String)
    public init?(intValue: Swift.Int)
    public typealias RawValue = Swift.String
    public var intValue: Swift.Int? {
      get
    }
    public var rawValue: Swift.String {
      get
    }
    public var stringValue: Swift.String {
      get
    }
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension NotificareKit.NotificareOptions {
  public func theme(for controller: UIKit.UIViewController) -> NotificareKit.NotificareOptions.Theme?
}
@_inheritsConvenienceInitializers @objc(NotificareCoreDataEvent) public class NotificareCoreDataEvent : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
extension NotificareKit.NotificareCoreDataEvent {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<NotificareKit.NotificareCoreDataEvent>
  @objc @NSManaged dynamic public var data: Foundation.Data? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var deviceId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var notificationId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var retries: Swift.Int16 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var sessionId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var timestamp: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var ttl: Swift.Int32 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var type: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var userId: Swift.String? {
    @objc get
    @objc set
  }
}
extension NotificareKit.NotificareCoreDataEvent : Swift.Identifiable {
  public typealias ID = Swift.ObjectIdentifier
}
extension NotificareKit.NotificareInternals.Module : Swift.Equatable {}
extension NotificareKit.NotificareInternals.Module : Swift.Hashable {}
extension NotificareKit.NotificareInternals.Module : Swift.RawRepresentable {}
extension NotificareKit.NotificareApplication.ServiceKey : Swift.Equatable {}
extension NotificareKit.NotificareApplication.ServiceKey : Swift.Hashable {}
extension NotificareKit.NotificareApplication.ServiceKey : Swift.RawRepresentable {}
extension NotificareKit.NotificareNotification.NotificationType : Swift.Equatable {}
extension NotificareKit.NotificareNotification.NotificationType : Swift.Hashable {}
extension NotificareKit.NotificareNotification.NotificationType : Swift.RawRepresentable {}
extension NotificareKit.NotificareNotification.Action.ActionType : Swift.Equatable {}
extension NotificareKit.NotificareNotification.Action.ActionType : Swift.Hashable {}
extension NotificareKit.NotificareNotification.Action.ActionType : Swift.RawRepresentable {}
extension NotificareKit.NotificareReachability.Connection : Swift.Equatable {}
extension NotificareKit.NotificareReachability.Connection : Swift.Hashable {}
extension NotificareKit.NotificareLocalizable.StringResource : Swift.Equatable {}
extension NotificareKit.NotificareLocalizable.StringResource : Swift.Hashable {}
extension NotificareKit.NotificareLocalizable.StringResource : Swift.RawRepresentable {}
extension NotificareKit.NotificareLocalizable.ImageResource : Swift.Equatable {}
extension NotificareKit.NotificareLocalizable.ImageResource : Swift.Hashable {}
extension NotificareKit.NotificareLocalizable.ImageResource : Swift.RawRepresentable {}
extension NotificareKit.NotificareOptions.CodingKeys : Swift.Equatable {}
extension NotificareKit.NotificareOptions.CodingKeys : Swift.Hashable {}
extension NotificareKit.NotificareOptions.CodingKeys : Swift.RawRepresentable {}
extension NotificareKit.NotificareOptions.Themes.CodingKeys : Swift.Equatable {}
extension NotificareKit.NotificareOptions.Themes.CodingKeys : Swift.Hashable {}
extension NotificareKit.NotificareOptions.Themes.CodingKeys : Swift.RawRepresentable {}
extension NotificareKit.NotificareOptions.Theme.CodingKeys : Swift.Equatable {}
extension NotificareKit.NotificareOptions.Theme.CodingKeys : Swift.Hashable {}
extension NotificareKit.NotificareOptions.Theme.CodingKeys : Swift.RawRepresentable {}
